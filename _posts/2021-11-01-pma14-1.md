---
title: "Practical Malware Analysis 14-1"
categories:
  - Practical Malware Analysis
tags:
  - Malware
layout: archive
layout: single
author_profile: true
sidebar:
  nav: "docs"
toc: true
toc_sticky: true
toc_label: "목차"
---

# 실습 14-1

실습 환경 : Vmware (Windows 7 32 bit)

사용한 툴 : IDA Free, ApateDNS, NC

ApateDNS를 사용하여 127.0.0.1로 서버를 실행한 뒤 nc를 이용해서 80번 포트로 리스닝하게 설정하고 악성코드를 동적으로 실행해 보면 아래와 같이 확인할 수 있다.

![lab14-1 1](https://user-images.githubusercontent.com/91646923/139655833-56a16e76-ea08-48dc-9d77-5054691e2ce6.JPG)
![lab14-1 2](https://user-images.githubusercontent.com/91646923/139655843-3972a55c-d564-4cdc-9a90-e5ada98e14f3.JPG)

인터넷 익스플로러를 이용해 테스트를 해보니 위 비컨에서 확인한 User-Agnet와 일치하는 것을 확인할 수 있다.

![lab14-1 3](https://user-images.githubusercontent.com/91646923/139659219-1307e1fb-ae82-4ea4-92b2-b2105cb9adc4.JPG)

이를 통해 User-Agent가 하드 코딩 되어있지 않은 것으로 생각할 수 있다.

이제 IDA Free를 사용하여 분석을 진행하보면

![lab14-1 4](https://user-images.githubusercontent.com/91646923/139659876-3477b4ea-a9bf-4736-9e8c-9807947c484a.JPG)

임포트 함수에서 URLDownloadToCacheFileA 함수를 찾을 수 있는데 이 함수가 비컨으로 사용되는 것으로 보이고 COM API를 사용하는 것을 확인할 수 있다.

URLDownloadToCacheFileA 함수가 유일하게 사용된 네트워크 함수로 보이므로 이 함수가 참조하는 0x004011A3 위치의 함수를 분석해보면

![lab14-1 5](https://user-images.githubusercontent.com/91646923/139660800-ddde31cb-a1a2-4fd3-8462-deef5e781651.JPG)
![lab14-1 6](https://user-images.githubusercontent.com/91646923/139660808-0a7ceae5-70e7-49af-848c-088a2a140393.JPG)

http://www.practicalmalwareanlysis.com/%s/%c.png를 sprintf 함수의 호출에 사용하고 그 결과를 URLDownloadToCacheFileA 함수의 파라미터로 사용하는 것을 볼 수 있다.

%s와 %c에 입력 값을 추척해보면

![lab14-1 7](https://user-images.githubusercontent.com/91646923/139661658-25de6f83-5618-40cb-9d93-f0f010ddf2e2.JPG)

함수 입력 값을 eax로 옮기고 strlen의 파라미터로 줘서 입력 값의 길이를 구한다. 그리고 구한 입력 값의 길이값을 var_218에 저장한 뒤 ecx에 입력 값을 저장하고 길이를 더해 문자열의 끝을 가리킨다.
그 뒤 dl에 문자열의 마지막 문자를 저장하고 dl을 var_214로 옮기고 다시 eax로 옮기고 push하는데 이 값이 %c의 인자이다. 그 후 ecx에 입력 값을 저장하고 push하는데 이 값이 %s의 인자이다.

즉 %c는 입력 값의 마지막 문자이고 %s는 입력 한 값임을 알 수 잇다. 이를통해 위에서 확인했던 비컨의 url 파일명이 a.png인 이유를 알 수 있다.

이제 어떤한 값이 입력되는지 호출 함수를 살펴보면

![lab14-1 8](https://user-images.githubusercontent.com/91646923/139664035-be3ea961-dc05-425f-8d42-c6b2e4fb692e.JPG)

sub_4010BB라는 이름의 함수를 볼 수 있는데 이 함수가 0x004011A3함수로 전달하는 문자열을 수정하는 것으로 보인다.

sub_4010BB 함수를 살펴보면

![lab14-1 9](https://user-images.githubusercontent.com/91646923/139664835-bc58ce97-f37f-4e09-a051-a528d8cd76af.JPG)
![lab14-1 10](https://user-images.githubusercontent.com/91646923/139664843-ff0540ed-e0ee-42cf-a33a-31f5df34ddee.JPG)

strlen과 sub_401000 두 개의 서브루틴을 갖고 있음을 알 수 있는데 sub_401000을 분석해보면

![lab14-1 11](https://user-images.githubusercontent.com/91646923/139666438-eccda5f5-c780-409a-9b7b-867b0a8bda03.JPG)

표준 base64 문자열 참조 값을 가지고 있는 것을 확인할 수 있지만 이는 표준 base64 인코딩 함수가 아니다. 왜냐하면 표준 base64 함수는 전형적으로 마지막 4바이트 블록의 문자 패딩에 필요할 경우 두 문자를 패딩할 수 있게 두개의 =를 참조하는데 위에서 살펴보면 패딩 문자로 일반적인 =이 아닌 a를 할당하는 것으로 보인다.

이제 메인 함수로 돌아가 분석을 진행해보면

![lab14-1 12](https://user-images.githubusercontent.com/91646923/139667235-635ed246-edfd-43f9-9611-7a19180fc648.JPG)

![lab14-1 13](https://user-images.githubusercontent.com/91646923/139667239-f0a8b9c6-5da6-4431-bab5-59fe149d2eaa.JPG)

![lab14-1 14](https://user-images.githubusercontent.com/91646923/139667241-eeeb6ac8-b509-4c5f-8473-b31fecdacb7d.JPG)

base64 인코딩 함수 전에 GetCurrentHwProfileA, GetUserName, sprintf함수와 문자열 들을 볼 수 있는데 이를 살펴보면 GetCurrentHwProfileA 함수가 반환한 GUID 여섯 바이트를 MAC주소 형식으로 출력하고 이 값은 %s-%s에서 첫 번째 문자열이 된다. GetUserName 함수를 사용하여 가져온 username은 %s-%s의 두 번째 값이 되니 이를 통해 문자열을 나타내보면 HH:HH:HH:HH:HH:HH-username이 된다.

이제 위에서 확인해 봤던 비컨의 url값을 base64로 디코딩을 해보면

![lab14-1 15](https://user-images.githubusercontent.com/91646923/139668618-eeb86834-4d92-44f7-bde0-5cf4441823f0.JPG)

위에서 확인했던 형식의 값임을 확인할 수 있다.

이제 다시 URLDownloadToCacheFileA 함수로 돌아가서 살펴보면

![lab14-1 16](https://user-images.githubusercontent.com/91646923/139668857-be3a1b5c-8f37-45da-9793-829a52d2f97e.JPG)

함수가 성공했을 때 URLDownloadToCacheFileA 함수가 반환한 경로명 하나를 인자로 받는 CreateProcessA 함수를 확인할 수 있다. 이를통해 악성코드가 파일을 다운로드하고 파일을 실행한 후 종료하는 것을 알 수 있다.

이제 네트워크 시그니처를 작성해 보면 시그니처 분석 대상이 되는 주요 정적 요소는 하드웨어 프로파일 바이트와 사용자명 사이에 있는 패딩을 제공하는 콜론과 대시다. 근데 악성코드가 네트워크상에서 이 콘텐츠를 전송하기 전에 base64 인코딩을 적용하기 때문에 이를 대상으로 하기는 어렵다. 대상 패턴과 문자열이 변환되는 방식을 나타내보면

|:원본:|80\:|6e\:|6f\:|6e\:|69\:|63-|use|r..|
|:인코딩:|QDA6|NmU6|NmY6|NmU6|NjK6|NjMt|dXNl|cgaa|
